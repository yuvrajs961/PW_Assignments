# -*- coding: utf-8 -*-
"""Module7_Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vjLiFUtHFlzsz8o79WhJgQ0j9A_0Nkh8
"""

#Question1: What are the five key concepts of Object-Oriented Programming (OOP)?
#Answer1: The five key concepts of Object-Oriented Programming (OOP) are:
# Encapsulation: Bundling data and methods that operate on the data into a single unit (class), restricting direct access to some components.
# Abstraction: Hiding complex implementation details and exposing only the necessary functionalities.
# Inheritance: Allowing a class (child) to inherit properties and methods from another class (parent).
# Polymorphism: Allowing objects to take on many forms, enabling methods to behave differently based on the object.

#Question 2: Write a Python class for a Car with attributes for make, model, and year. Include a method to display the car's information.
#Answer 2: Below is a Python class for a Car:
class Car:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year

    def display_info(self):
        print(f"Car Information: {self.year} {self.make} {self.model}")

# Example usage:
car = Car("Toyota", "Corolla", 2020)
car.display_info()

# Question 3: Explain the difference between instance methods and class methods. Provide an example of each.
# Answer 3: Difference between Instance Methods and Class Methods:
# Instance Methods:

# Operate on an instance of the class.
# Have access to the instance's attributes and methods via self.
# Defined without any decorators.
# Class Methods:
# Operate on the class itself rather than any particular instance.
# Can modify the class state or access class-level attributes via cls.
# Defined using the @classmethod decorator.
class Example:
    class_attribute = "I am a class attribute"

    def __init__(self, value):
        self.instance_attribute = value

    # Instance method
    def instance_method(self):
        return f"Instance method called: {self.instance_attribute}"

    # Class method
    @classmethod
    def class_method(cls):
        return f"Class method called: {cls.class_attribute}"

# Using instance method
obj = Example("I am an instance attribute")
print(obj.instance_method())

# Using class method
print(Example.class_method())

# Question 4: How does Python implement method overloading? Give an example.
# Answer 4: Python does not support method overloading in the traditional sense like some other languages. Instead, Python uses default arguments or variable arguments (*args and **kwargs) to achieve similar functionality.

# Example of Simulating Method Overloading:
class Calculator:
    def add(self, a, b=0, c=0):
        return a + b + c

# Example usage
calc = Calculator()
print(calc.add(5))
print(calc.add(5, 10))
print(calc.add(5, 10, 15))

# Here, the add method can accept one, two, or three arguments, simulating overloading behavior.

# For more complex scenarios, you can use *args and **kwargs to handle a varying number of arguments dynamically:
class Calculator:
    def add(self, *args):
        return sum(args)

# Example usage
calc = Calculator()
print(calc.add(5))
print(calc.add(5, 10))
print(calc.add(5, 10, 15))

# Question 5: What are the three types of access modifiers in Python? How are they denoted?
# Answer 5: Python has three types of access modifiers:
# Public:
# Accessible from anywhere, both inside and outside the class.
# Denoted without any leading underscore (e.g., attribute).
# Protected:
# Accessible within the class and its subclasses.
# Denoted with a single leading underscore (e.g., _attribute).
# Private:
# Accessible only within the class, not directly accessible outside it.
# Denoted with a double leading underscore (e.g., __attribute).

# Question 6: Describe the five types of inheritance in Python. Provide a simple example of multiple inheritance.
# Answer 6: Five Types of Inheritance in Python:
# Single Inheritance:
# A child class inherits from one parent class.
# Example: class Child(Parent):.
# Multiple Inheritance:
# A child class inherits from more than one parent class.
# Example: class Child(Parent1, Parent2):.
# Multilevel Inheritance:
# A child class inherits from a parent class, and another class inherits from the child class.
# Example: class GrandChild(Child):.
# Hierarchical Inheritance:
# Multiple child classes inherit from a single parent class.
# Example: class Child1(Parent), class Child2(Parent):.
# Hybrid Inheritance:
# A combination of two or more types of inheritance.
# Example of Multiple Inheritance:
class Parent1:
    def feature1(self):
        print("Feature from Parent1")

class Parent2:
    def feature2(self):
        print("Feature from Parent2")

class Child(Parent1, Parent2):
    def feature3(self):
        print("Feature from Child")

# Question 7: What is the Method Resolution Order (MRO) in Python? How can you retrieve it programmatically?
# Answer 7: Method Resolution Order (MRO):
# The Method Resolution Order (MRO) in Python determines the sequence in which a class and its ancestors are searched when looking for a method or attribute. It ensures that methods are inherited in a consistent and predictable manner, especially in multiple inheritance scenarios.
# MRO follows the C3 Linearization algorithm, which:
# Preserves the order of inheritance specified in the class definition.
# Ensures that child classes are checked before parent classes.
# Resolves conflicts in multiple inheritance hierarchies.
# How to Retrieve MRO Programmatically:
# You can use one of the following methods:
# ClassName.__mro__: Returns a tuple of the MRO.
# ClassName.mro(): Returns a list of the MRO.
# help(ClassName): Displays MRO along with other class details.

class A:
    pass
class B(A):
    pass
class C(A):
    pass
class D(B, C):
    pass
print(D.__mro__)
print(D.mro())

# Question 8: Create an abstract base class `Shape` with an abstract method `area()`. Then create two subclasses `Circle` and `Rectangle` that implement the `area()` method.
# Answer 8: Following is the way we can create an abstract base class Shape and implement the area() method in its subclasses Circle and Rectangle:
from abc import ABC, abstractmethod
import math

# Abstract base class
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

# Subclass Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

# Subclass Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Example usage
circle = Circle(5)
rectangle = Rectangle(4, 6)

print(f"Circle area: {circle.area():.2f}")
print(f"Rectangle area: {rectangle.area()}")

# Explanation:
# Abstract Base Class:
# Shape inherits from ABC (Abstract Base Class).
# The @abstractmethod decorator enforces the implementation of area() in subclasses.
# Circle and Rectangle:
# Both inherit from Shape and implement the area() method with logic specific to their shape.

# Question 9: Demonstrate polymorphism by creating a function that can work with different shape objects to calculate and print their areas.
# Answer 9: Following we can demonstrate polymorphism with a function that calculates and prints the areas of different shape objects:
from abc import ABC, abstractmethod
import math
# Abstract base class
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
# Subclass Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return math.pi * self.radius ** 2
# Subclass Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def area(self):
        return self.width * self.height
# Function demonstrating polymorphism
def print_area(shape):
    print(f"The area of the shape is: {shape.area():.2f}")
# Example usage
circle = Circle(5)
rectangle = Rectangle(4, 6)
# Using the polymorphic function
print_area(circle)
print_area(rectangle)
# Explanation:
# The print_area function takes an object of the Shape type and calls its area() method.
# Polymorphism allows print_area to work with different shape objects (Circle and Rectangle) without needing to know their specific types.

# Question 10: . Implement encapsulation in a `BankAccount` class with private attributes for `balance` and `account_number`. Include methods for deposit, withdrawal, and balance inquiry.
# Answer 10: Implementation of encapsulation in a BankAccount class:
class BankAccount:
    def __init__(self, account_number, initial_balance=0):
        self.__account_number = account_number
        self.__balance = initial_balance

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited: {amount:.2f}")
        else:
            print("Deposit amount must be positive.")

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Withdrawn: {amount:.2f}")
        else:
            print("Invalid withdrawal amount or insufficient funds.")

    def get_balance(self):
        return self.__balance

    def get_account_number(self):
        return self.__account_number

# Example usage
account = BankAccount("12345678", 1000)

# Deposit
account.deposit(500)
# Withdraw
account.withdraw(300)
# Balance inquiry
print(f"Balance: {account.get_balance():.2f}")


Here’s how you can implement encapsulation in a BankAccount class:

python
Copy code
class BankAccount:
    def __init__(self, account_number, initial_balance=0):
        self.__account_number = account_number  # Private attribute
        self.__balance = initial_balance        # Private attribute

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited: {amount:.2f}")
        else:
            print("Deposit amount must be positive.")

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Withdrawn: {amount:.2f}")
        else:
            print("Invalid withdrawal amount or insufficient funds.")

    def get_balance(self):
        return self.__balance

    def get_account_number(self):
        return self.__account_number

# Example usage
account = BankAccount("12345678", 1000)

# Deposit
account.deposit(500)
# Withdraw
account.withdraw(300)
# Balance inquiry
print(f"Balance: {account.get_balance():.2f}")

# Explanation:
# Encapsulation:
# __account_number and __balance are private attributes, not directly accessible outside the class.
# Methods like deposit, withdraw, and get_balance control access to these attributes.
# Methods:
# deposit: Adds money to the account after validating the amount.
# withdraw: Deducts money if sufficient balance is available.
# get_balance: Provides read-only access to the balance.
# get_account_number: Provides read-only access to the account number.

# Question 11: Write a class that overrides the `__str__` and `__add__` magic methods. What will these methods allow you to do?
# Answer 11: __str__ and __add__ Magic Methods:
# __str__ Method:
# The __str__ method is used to define how an object should be represented as a string. When you call str(object) or use print(object), the __str__ method is invoked.
# Purpose: To provide a human-readable, user-friendly string representation of the object, making it easier to understand its content.
# __add__ Method:
# The __add__ method is used to define how the + operator behaves for objects of a class. It allows you to customize the behavior of addition between instances of that class.
# Purpose: To define the logic for adding two objects together, such as combining attributes or performing arithmetic operations.
# What These Methods Allow You to Do:
# __str__: Customize how your objects are displayed when printed or converted to a string, making debugging and logging more intuitive.
# __add__: Allow instances of your class to be added together using the + operator, enabling meaningful operations between objects (such as combining two vectors, adding monetary amounts, etc.).

# Question 12: Create a decorator that measures and prints the execution time of a function.
# Answer 12: Following is the method to create a decorator to measure and print the execution time of a function:

import time
def measure_execution_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Execution time: {execution_time:.4f} seconds")
        return result
    return wrapper

# Example usage of the decorator
@measure_execution_time
def sample_function():
    time.sleep(20)

# Call the function
sample_function()

# Explanation:
# Decorator: The measure_execution_time decorator wraps a function and measures the time it takes to execute.
# time.time(): It records the time before and after the function call to compute the execution duration.
# wrapper function: It serves as the actual function that gets called in place of the original function, allowing us to measure the time around it.

# Question 13: Explain the concept of the Diamond Problem in multiple inheritance. How does Python resolve it?
# Answer 13: The Diamond Problem in Multiple Inheritance:
# The Diamond Problem occurs in object-oriented programming when a class inherits from two classes that both inherit from a common base class. This creates a diamond-shaped inheritance hierarchy, where the derived class has multiple paths to the same base class. The issue arises when a method or attribute from the common base class is inherited through both parent classes, leading to ambiguity about which method or attribute should be used.

# For example, if both parent classes override a method from the base class, it's unclear which version of the method should be called in the derived class.
# How Python Resolves the Diamond Problem:
# Python resolves the Diamond Problem using the C3 Linearization Algorithm (also called C3 superclass linearization). This method determines the order in which base classes are considered during method resolution, ensuring that:
# The derived class gets methods from its direct parent classes.
# The common base class is considered only once, even if it’s inherited through multiple paths.
# The MRO (Method Resolution Order) ensures that the class hierarchy is traversed in a consistent order.
# Python’s MRO guarantees that each class in the inheritance chain is checked in a predictable and well-defined order, avoiding ambiguity.
# This is implemented and can be observed by using the __mro__ attribute or mro() method to view the method resolution order of a class.

# Question 14: Write a class method that keeps track of the number of instances created from a class.
# Answer 14: Class method that keeps track of the number of instances created from a class:
class MyClass:
    instance_count = 0  # Class variable to store the count of instances
    def __init__(self):
        MyClass.instance_count += 1  # Increment the count when a new instance is created
    @classmethod
    def get_instance_count(cls):
        return cls.instance_count  # Return the current instance count
# Example usage
obj1 = MyClass()
obj2 = MyClass()
obj3 = MyClass()
print(f"Number of instances created: {MyClass.get_instance_count()}")
# Explanation:
# instance_count: A class variable that stores the number of instances created.
# __init__: The constructor increments the instance_count every time a new instance is created.
# get_instance_count: A class method that returns the current value of instance_count. It uses the @classmethod decorator to access the class variable.

# Question 15: Implement a static method in a class that checks if a given year is a leap year.
# Answer 15: Implementation of a static method in a class that checks if a given year is a leap year:
class YearUtils:
    @staticmethod
    def is_leap_year(year):
        # A leap year is divisible by 4, but not divisible by 100, except when it is divisible by 400.
        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            return True
        else:
            return False

# Example usage
year = 2024
print(f"Is {year} a leap year? {YearUtils.is_leap_year(year)}")

year = 2023
print(f"Is {year} a leap year? {YearUtils.is_leap_year(year)}")

# Explanation:
# @staticmethod: The static method decorator is used because the method does not depend on instance or class-specific data. It only needs the input argument (year).
# Leap year rules: A year is a leap year if it is divisible by 4, but not divisible by 100, unless it is also divisible by 400.